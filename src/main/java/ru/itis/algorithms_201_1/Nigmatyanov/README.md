<h1>Тимсорт</h1>
<h2>Описание Алгоритма</h2>
Timsort — гибридный алгоритм сортировки, сочетающий сортировку вставками и сортировку слиянием, опубликованный в 2002 году Тимом Петерсом.
Основная идея алгоритма в том, что в реальном мире сортируемые массивы данных часто содержат в себе упорядоченные подмассивы. На таких данных Timsort существенно быстрее многих алгоритмов сортировки. Если же данные распределены случайным образом, то массив будет отсортирован ~ сортировкой слиянием, что довольно быстро. Если в массиве меньше чем 64 элемента, то они будут отсортированы сортировкой вставками.
Алгоритм Timsort состоит из нескольких частей:

    Начало.
    Шаг 1. Входной массив разделяется на подмассивы фиксированной длины, вычисляемой определённым образом.
    Шаг 2. Каждый подмассив сортируется сортировкой вставками, сортировкой пузырьком или любой другой устойчивой сортировкой.
    Шаг 3. Отсортированные подмассивы объединяются в один массив с помощью модифицированной сортировки слиянием.
    Конец.
<h2>Временная сложность</h2>
Лучший случай достигается если исходный массив упорядочен по возрастанию/убыванию. В таком случае run будет единственным и будет равен длине массива, и после сортировки вставками по уже упорядоченному массиву алгоритм завершится - O(n).<br><br>
Худший случай достигается если в заданном массиве элементы расположены случайно. Тогда можно считать, что внутри нет упорядоченных подпоследовательностей. В таком случае все run'ы, на которые разделяется массив, будут иметь приблизительно одинаковую длину - minRun. Таким образом, каждый подмассив run может участвовать не более чем в O(logn) операций слияния, а значит и каждый элемент будет задействован в сравнениях не более O(logn) раз. Элементов n, откуда получаем оценку в O(nlogn). <br><br>
Средний случай достигается если в исходном массиве часть подмассивов уже отсортирована. На таких подмассивах быстрее сработает сортировка вставками. Также некоторые run могут иметь длины, большие чем minRun(могут и не иметь). Тогда может уменьшиться число операций слияния подмассивов. В худшем случае среднего случая число операций слияния не изменится и нам, как и в худшем случае, придется выполнить O(nlogn) действий.<br>
<h2>Пространственная сложность</h2>
Сложность по памяти напрямую следует из сложности по памяти Merge Sort - O(n), т.к. в процессе объединения двух массивов нам приходиться заводить третий, временный, в который мы копируем один из объединяемых массивов.
<br>
<br>
<h1>Графики</h1>
Зависимость времени выполнения алгоритма(нс) от размера вводного массива(синий). График nlog_2_n(оранжевый).

![Снимок экрана 2023-03-25 174543](https://user-images.githubusercontent.com/113761790/227744566-f32484a4-99b9-4fa6-845f-e56f1d39719a.png)

<br>

График, полученный делением времени выполнения алгоритма на nlogn. Заметьте, что он приближается к константе при увеличении длины массива. Это и означает, что время выполнения алгоритма - O(nlogn)
![Снимок экрана 2023-03-25 143637](https://user-images.githubusercontent.com/113761790/227744627-bcf5078e-e5c7-43fd-91f0-396047c96665.png)
<br>
<br>
Зависимость числа итераций от размера вводного масива. Сравните его с графиком выше, самым первым: при размере массива 2^k или несколько больше количество итераций становится меньше, чем при размере несколько меньшем чем 2^k, но время выполнения программы чуть возрастает. Это происходит потому, что происходит переход с minRun = 63 на minRun = 32. в этом случае количество итераций резко уменьшается( т.к. сортировка вставками для каждого run начинает работать за меньше число операций), но время программы растёт, потому что приходится объединять большее число run'ов. 
![Снимок экрана 2023-03-25 174532](https://user-images.githubusercontent.com/113761790/227744700-b0cef050-d21d-4218-89e9-cdcfbcc29545.png)
