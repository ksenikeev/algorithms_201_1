## TreeSort
**Универсальный алгоритм сортировки**, заключающийся в построении **двоичного дерева** поиска по ключам массива (списка), с последующей сборкой результирующего массива путём обхода узлов построенного **дерева** в необходимом порядке следования ключей.

## Описание алгоритма
1 шаг. Начинаем с построения **дерева**. Первый элемент массива становится **корнем** дерева (началом). Остальные элементы (начиная со второго) начинают сравниваться с первым.

2 шаг. Начинаем сравнение:
	1) Если значение элемента меньше или равен значению корня, то мы проверяем, есть ли у корня **левое поддерево**. Если есть, то возвращаемся к шагу 2, только корнем для нашего элемента становится левое поддерево (спускаемся на уровень ниже). Если нет, то создаём и записываем туда значение нашего элемента.
	2) Если значение элемента больше значения корня, то мы проверяем, есть ли у корня **правое поддерево**. Если есть, то возвращаемся к шагу 2, только корнем для нашего элемента становится правое поддерево (спускаемся на уровень ниже). Если нет, то создаём и записываем туда значение нашего элемента.
	
Когда закончится сравнение, мы увидим, что если у нас есть левое поддерево любого узла Х, то значения этого поддерева всегда меньше или равно значению самого узла Х. Таким образом, значение **самого** левого поддерева является **минимальным**, а значение **самого** правого поддерева - **максимальным**.

Отсюда и следует 3 шаг.

3 шаг. Выводим отсортированный массив. 
Опять же, начинаем с корня. Чтобы вывести первое (оно же минимальное) значение, нужно от корня просто пойти **по левому краю дерева**. **Выписываем** этот элемент и **помечаем** это поддерево **как пройденное**. Дальше действия **рекурсивные**, поэтому отмечу. (1) Перед тем как вернуться к родителю мы проверяем, есть ли у нашего поддерева **не помеченное** правое поддерево. Если есть, переходим к нему. (2) Смотрим, есть ли у него левое поддерево, если нет, то **выписываем** значение этого поддерева, **помечаем** его **как пройденное** и возвращаемся к предложению (1). Если есть, то возвращаемся сюда (2), спустившись к этому поддереву. Когда мы **пометили** все поддеревья поддерева Х и **выписали** их значения, то мы возвращаемся к родителю поддерева Х.

Я не знаю, как объяснить это проще, просто нужно понимать, что у нас рекурсивный алгоритм и мы постоянно спускаемся на уровень ниже до определённого момента.


## Оценка сложности

Временная сложность:
1) в лучшем случае: (O(n*log(n))
2) в среднем случае: (O(n*log(n))
2) в худшем случае: (O(n²))

Процедура  добавления  объекта  в  бинарное  дерево  имеет  среднюю  алгоритмическую  сложность  порядка  O(log(n)). Это происходит потому, что элемент сравнивается с корнем и элемент идёт либо вправо, либо влево, соответственно, половина дерева сразу отпадает. И так на каждом шаге. Соответственно,  для  n  объектов  сложность  будет  составлять  O(n  log(n)),  что  относит  сортировку  с  помощью  двоичного  дерева  к  группе  «быстрых  сортировок».  Однако,  сложность  добавления  объекта  в дерево  может  достигать  O(n),  что  может  привести  к  общей  сложности  порядка  O(n²). Это может произойти, если дерево имеет всего одну ветку (и тогда добавление элемента может проходить через все поддеревья)

Пространственная память: O(n)

При  физическом  развёртывании  древовидной  структуры  в  памяти  требуется  не  менее  чем  4n  ячеек  дополнительной  памяти (каждый  узел  должен  содержать  ссылки  на  элемент  исходного  массива, на  родительский  элемент, на  левый  и  правый  лист)
